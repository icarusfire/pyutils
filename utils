import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

def evp_bytes_to_key(password, salt, key_len, iv_len):
    """
    Derives the key and IV using OpenSSL's EVP_BytesToKey method.
    """
    password = password.encode('utf-8')
    derived_data = b""
    block = b""
    while len(derived_data) < key_len + iv_len:
        block = hashlib.md5(block + password + salt).digest()
        derived_data += block
    return derived_data[:key_len], derived_data[key_len:key_len+iv_len]

def decrypt_file(input_file, output_file, secret_key="dummyKey"):
    # Read the encrypted file
    with open(input_file, 'rb') as f:
        # Read the first 8 bytes for the salt header (includes "Salted__")
        salt_header = f.read(8)
        if not salt_header.startswith(b"Salted__"):
            raise ValueError("Invalid salt format, expected 'Salted__' in the beginning")
        
        # Read the next 8 bytes as the actual salt (after 'Salted__')
        salt = f.read(8)
        
        # Derive the key and IV using OpenSSL's EVP_BytesToKey method
        key, iv = evp_bytes_to_key(secret_key, salt, 32, 16)
        
        # Read the ciphertext
        ciphertext = f.read()
    
    # Create the cipher object
    cipher = AES.new(key, AES.MODE_CBC, iv)
    
    # Decrypt the ciphertext
    decrypted_data = cipher.decrypt(ciphertext)
    
    # Unpad the decrypted data
    try:
        decrypted_data = unpad(decrypted_data, AES.block_size)
    except ValueError as e:
        print(f"Error during unpadding: {e}")
        return
    
    # Write the decrypted data to the output file
    with open(output_file, 'wb') as f:
        f.write(decrypted_data)

